using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Runtime.Serialization;
using Dg.Deblazer.Api;
using Dg.Deblazer.Cache;
using Dg.Deblazer.Configuration;
using Dg.Deblazer.Internal;
using Dg.Deblazer.Visitors;

namespace Dg.Deblazer
{
    [Serializable]
    public class DbEntitySet<TMember> : IDbEntitySet<TMember>, IDbEntitySetInternal, ISerializable where TMember : DbEntity
    {
        private readonly object loadLock = new object();
        private Action<TMember> afterRightsCheckAction;
        private Action<TMember> beforeRightsCheckAction;

        private string[] columns;
        internal IDbInternal db;
        private Func<long?>[] foreignKeys;

        private bool isForeignKey;
        internal bool lazyLoadValues = true;
        private DbEntity parent;
        private Action<TMember, DbEntity> setParent;

        private HashSet<TMember> toBeIgnoredWhenLoaded;
        private List<TMember> entities;
        protected bool valuesLoaded = false;
        private HashSet<TMember> valuesSet;

        protected DbEntitySet(SerializationInfo info, StreamingContext context)
        {
            entities = info.GetValue("entities", typeof(List<TMember>)) as List<TMember>;
            valuesLoaded = info.GetBoolean("vl");
            lazyLoadValues = info.GetBoolean("llv");
        }

        public DbEntitySet(
            IDb db,
            bool isForeignKey,
            Func<long?>[] foreignKeys,
            string[] columns,
            Action<TMember, DbEntity> setParent,
            DbEntity parent,
            bool lazyLoadValues,
            Action<TMember> beforeRightsCheckAction,
            Action<TMember> afterRightsCheckAction)
        {
            InitValuesList();
            valuesLoaded = false;
            lazyLoadValues = true;
            Init(db, isForeignKey, foreignKeys, columns, setParent, parent, lazyLoadValues, beforeRightsCheckAction, afterRightsCheckAction);
        }

        private HashSet<TMember> ToBeIgnoredWhenLoaded
        {
            get
            {
                if (toBeIgnoredWhenLoaded == null)
                {
                    toBeIgnoredWhenLoaded = new HashSet<TMember>();
                }

                return toBeIgnoredWhenLoaded;
            }
        }

        private IList<TMember> Values
        {
            get
            {
                if (!valuesLoaded && foreignKeys.All(k => k() > 0))
                {
                    if (!lazyLoadValues)
                    {
                        throw new InvalidOperationException(
                            $"Cannot load {typeof(TMember).Name}s ({string.Join(",", columns)} {string.Join(",", foreignKeys.Select(i => i().ToString()))}) because lazy loading of value is disabled");
                    }

                    lock (loadLock)
                    {
                        if (!valuesLoaded)
                        {
                            // Get the existing values
                            if (entities != null)
                            {
                                ToBeIgnoredWhenLoaded.UnionWith(entities);
                            }

                            IReadOnlyList<TMember> entitiesFromDb;
                            string columnKey = string.Join("|", columns);
                            string idKey = string.Join("|", foreignKeys.Select(i => i().ToString()));
                            if (db == null
                                || !db.LoadedEntityCache.TryGet(columnKey, idKey, out entitiesFromDb))
                            {
                                if (db == null)
                                {
                                    InitDb();
                                }

                                // Try to load the entities from the db
                                entitiesFromDb = GetQuery();
                                entitiesFromDb = (IReadOnlyList<TMember>)db?.LoadedEntityCache.GetOrAdd(typeof(IReadOnlyList<TMember>), columnKey, idKey, entitiesFromDb);
                            }

                            // Because items are added from the db before the rights check, we need to remember which items have been
                            // removed from the set already before the db load and have to be removed again after the items have been loaded
                            var itemsToRemove = ToBeIgnoredWhenLoaded.Except(valuesSet).ToList();
                            // Initialize the list properly to prevent too large lists being generated by default. See List<>.EnsureCapacity

                            if (entitiesFromDb != null)
                            {
                                InitValuesList(listCapacity: entitiesFromDb.Count);

                                foreach (TMember entity in entitiesFromDb)
                                {
                                    if (toBeIgnoredWhenLoaded == null || !ToBeIgnoredWhenLoaded.Contains(entity))
                                    {
                                        Add(entity);
                                    }
                                }
                            }
                            else
                            {
                                InitValuesList(listCapacity: 0);
                            }

                            foreach (var entity in itemsToRemove)
                            {
                                if (entities != null && entities.Remove(entity))
                                {
                                    valuesSet.Remove(entity);
                                }

                                // Do not use Remove(entity), because we do not want to call setParent(item, null);
                                // if itemProduct.ItemProductStatic = newIps is called, and later oldIps.ItemProducts is called,
                                // we only want to remove the already removed itemProduct, but we don't want to set itemProduct.ItemProductStatic = null
                            }

                            valuesLoaded = true;
                            // ResetLoadOverhead();
                        }
                    }
                }

                return entities;
            }
        }

        private void InitDb()
        {
            var dbConfiguration = GlobalDbConfiguration.GetConfigurationOrEmpty(typeof(TMember));

            if (dbConfiguration.GetDbForEvilLazyLoad != null)
            {
                db = dbConfiguration.GetDbForEvilLazyLoad();
            }
            else
            {
                throw new LazyLoadUnattachedEntityException("Lazy loading on a newly created entity which was not loaded from database is not allowed!");
            }
        }

        public long? ForeignKey
        {
            get { return foreignKeys[0](); }
        }

        public IEnumerable<TMember> ValuesNoLoad
        {
            get { return entities ?? Enumerable.Empty<TMember>(); }
        }

        public void Add(TMember entity)
        {
            if (!lazyLoadValues)
            {
                throw new InvalidOperationException($"Lazy loading of values of type {typeof(TMember).Name} is disabled, so is adding values");
            }

            if (entity != null && !valuesSet.Contains(entity))
            {
                if (((ILongId)entity).Id == 0)
                {
                    // When the Id of the Entity changes (e.g. it is inserted into the DB and the Id is changed from 0 to the real Id), GetHashCode() returns
                    // another value and Equality is checked differently too. We have to remove the Entity before the Id changes and readd it afterwards, otherwise
                    // we would not find the entity in the set afterwards.
                    entity.IdChanging += (object sender, EventArgs e) => { valuesSet.Remove((TMember)sender); };
                    entity.IdChanged += (object sender, EventArgs e) => { valuesSet.Add((TMember)sender); };
                }

                InitValuesList();
                valuesSet.Add(entity);
                entities.Add(entity);
                if (entity._lazyLoadChildren)
                {
                    setParent(entity, parent);
                }
            }
        }

        public void AddRange(IEnumerable<TMember> entities)
        {
            foreach (TMember entity in entities)
            {
                Add(entity);
            }
        }

        public void Attach(IEnumerable<TMember> entities)
        {
            // 2TK BDA Event? Geht dann der Stacktrace verloren?
//#if DEBUG
//            if (DbEntity.WarnDeveloperIfEntitiesAlreadyConnected
//                && MachineInfo.IsDevelopmentMachine
//                && valuesSet.Any())
//            {
//                if (Debugger.IsAttached)
//                {
//                    // Entity ist bereits da. Es wurde bereits vor dem Attach zugegriffen was nicht gut ist
//                    Debugger.Break();
//                }
//            }
//#endif

            AddRange(entities);
            valuesLoaded = true;
        }

        public void Insert(int index, TMember entity)
        {
            if (!lazyLoadValues)
            {
                throw new InvalidOperationException($"Lazy loading of values of type {typeof(TMember).Name} is disabled, so is adding values");
            }

            InitValuesList();
            if (entity != null && !valuesSet.Contains(entity))
            {
                entities.Insert(index, entity);
                valuesSet.Add(entity);
                if (entity._lazyLoadChildren)
                {
                    setParent(entity, parent);
                }
            }
        }

        public void Clear()
        {
            // Does not work since upon Remove(), the cleared items have to be included in the update set, otherwise there will
            // be a foreign key reference exception, since we try to delete an object, but there are still foreign keys pointing to
            // it (which are not updated because the cleared items are not included in the update set)
            List<TMember> valuesList = Values.ToList();
            for (int i = 0; i < valuesList.Count; i++)
            {
                Remove(valuesList[i]);
            }
        }

        public bool Contains(TMember item)
        {
            return Values.Contains(item);
        }

        public void CopyTo(TMember[] array, int arrayIndex)
        {
            Values.CopyTo(array, arrayIndex);
        }

        public bool Remove(TMember item)
        {
            if (!valuesLoaded)
            {
                ToBeIgnoredWhenLoaded.Add(item);
            }

            if (entities != null)
            {
                if (entities.Remove(item))
                {
                    valuesSet.Remove(item);
                    // Remove the root object (e.g. portal.Mandator = null;)
                    setParent(item, null);
                    return true;
                }
            }

            return false;
        }

        public IEnumerator<TMember> GetEnumerator()
        {
            return Values.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public int Count
        {
            get { return Values.Count; }
        }

        public bool IsReadOnly
        {
            get { return false; }
        }

        public int IndexOf(TMember item)
        {
            return Values.IndexOf(item);
        }

        public void RemoveAt(int index)
        {
            TMember item = Values[index];
            if (Values.Remove(item))
            {
                valuesSet.Remove(item);
                setParent(item, null);
            }
        }

        public TMember this[int index]
        {
            get { return Values[index]; }

            set
            {
                RemoveAt(index);
                Insert(index, value);
            }
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("values", entities);
            info.AddValue("vl", valuesLoaded);
            info.AddValue("llv", lazyLoadValues);
        }

        [OnDeserialized]
        internal void OnDeserializedMethod(StreamingContext context)
        {
            if (entities != null)
            {
                valuesSet = new HashSet<TMember>(entities);
            }
        }

        private void InitValuesList(int listCapacity = 4)
        {
            if (entities == null)
            {
                entities = new List<TMember>(listCapacity);
                valuesSet = new HashSet<TMember>();
            }
        }

        internal void Init(
            IDb db,
            bool isForeignKey,
            Func<long?>[] foreignKeys,
            string[] columns,
            Action<TMember, DbEntity> setParent,
            DbEntity parent,
            bool lazyLoadValues,
            Action<TMember> beforeRightsCheckAction,
            Action<TMember> afterRightsCheckAction)
        {
            this.columns = columns;
            this.isForeignKey = isForeignKey;
            this.parent = parent;
            this.setParent = setParent;
            this.db = (IDbInternal)db;
            this.foreignKeys = foreignKeys;
            this.lazyLoadValues = lazyLoadValues;
            this.beforeRightsCheckAction = beforeRightsCheckAction;
            this.afterRightsCheckAction = afterRightsCheckAction;
        }

        protected virtual IReadOnlyList<TMember> GetQuery()
        {
            var query = db.LoadBy<TMember>(columns, foreignKeys.Select(i => (int)i()).ToArray());
            query.ValueLoadedBeforeRightsCheck += (DbEntity value) =>
            {
                if (toBeIgnoredWhenLoaded == null || !ToBeIgnoredWhenLoaded.Contains(value))
                {
                    beforeRightsCheckAction(value as TMember);
                }
            };
            // Reset the entity after it has been reset. Otherwise changes made to it are submitted to the db...
            query.ValueRemoved += (DbEntity value) =>
            {
                afterRightsCheckAction(value as TMember);
                new UpdateSetVisitor(doReset: true, columnsToReset: null, doProcessChildren: true).Process(value);
            };
            return query;
        }

        public override string ToString()
        {
            return "Count: " + (entities == null || (entities.Count == 0 && !valuesLoaded) ? "Not yet loaded" : entities.Count.ToString());
        }

        IReadOnlyList<DbEntity> IDbEntitySetInternal.EntitiesInternal => entities;

        bool IDbEntitySetInternal.IsForeignKey => isForeignKey;

        void IDbEntitySetInternal.SetDb(BaseDb db) => this.db = db;

        void IDbEntitySetInternal.DisableLazyLoadChildren() => lazyLoadValues = false;

        void IDbEntitySetInternal.EnableLoadingChildrenFromCache() { }

        void IDbEntitySetInternal.MakeReadOnly()
        {
            if (valuesLoaded)
            {
                foreignKeys = null;
                columns = null;
                setParent = null;
                db = null;
            }
        }

        bool IRaiseDbSubmitEvent.RaiseBeforeInsertEvent()
        {
            return false;
        }

        bool IRaiseDbSubmitEvent.RaiseBeforeUpdateEvent()
        {
            return false;
        }

        bool IRaiseDbSubmitEvent.RaiseBeforeDeleteEvent()
        {
            return false;
        }

        IImmutableSet<DbEntity> IRaiseDbSubmitEvent.RaiseAfterInsertEvent()
        {
            return ImmutableHashSet<DbEntity>.Empty;
        }

        bool IRaiseDbSubmitEvent.RaiseAfterDeleteEvent()
        {
            return false;
        }

        bool IRaiseDbSubmitEvent.RaiseOnSubmitTransactionAbortedEvent()
        {
            return false;
        }
    }
}